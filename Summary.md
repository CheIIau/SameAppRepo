### Summary

> Краткое саммари для будущего меня по использованным фреймворкам. Стоило, конечно, писать по мере разработки, чтобы ничего не забыть, но, к сожалению, писал постфактум, поэтому некоторые моменты, боли, плюсы по части фреймворков уже забылись.

1. lit - очень мало всего из коробки (хотя, вроде, есть достаточно много пакетов на оф странице) низкий уровень абстракции, ощущение, что пишешь на голом js, что одновременно плюс и минус, так как нужно изобретать свои велосипеды на те вещи, что, как правило, идут с фреймворком (справедливости ради, lit - библиотека). Вебкомпоненты - стандарт, который кроме angular больше никто не юзает из фреймворков, хорошая изоляция. Не самое очевидное подключение тейлвинда - для удобства собственная обертка над классом, ну такое себе. От версии к версии библиотека не сильно меняется, так что документация к первой версии по большей степени актуальна для третьей, вроде даже от Polymer местами подходит. Судя по звездам на гитхабе комьюнити должно быть довольно большое, хотя по факту фреймворк развивается довольно медленно, по сравнению с конкурентами выглядит сырым, хотя, если учитывать тот же полимер, либе больше 7 лет. Css переменные от родителя к ребенку передавать неудобно, нет вычисляемых свойств типа computed (а было бы неплохо), плохенькая документация (по крайней мере, хуже, чем у всех остальных фреймворков). Через их starter-kit создавать проект - боль, через vite - норм. Но, вроде, досточно удобная библиотека для запросов task. В целом, использовать, откровенно, не хочется. На других фреймворках, кажется, продуктивность заметно выше. Но lit и не ставит своей целью быть чем-то вроде реакта или vue и справляется со своей задачей создавать веб-компоненты. Наверно, в сколько угодно серьёзный проект смысла брать нет никакого. Разве что создать пару веб-компонентов и потом использовать где-то еще. Наверно... PS. еще почему-то ts server периодически крашился после установки расширения для вскода для lit. Может совпадение.

2. solid - очень близкий api к реакту, так что перекатиться с реакта довольно легко, к тому же есть библиотека, для использования солид-компонентов в реакте, но в этом кроется свое коварство - подходы принципиально разные, необходимо перестроить ментальную модель, и похожий апи немного путает. есть eslint правила для солида с хорошим фиксом (e.g. при попытке деструктуризировать пропсы, скажет, что так потеряется реактивность и сам обернет в splitProps, при попытке присвоить дефолтное значение - обернет в mergeProps. Клёво). Типы ивентов менее удобные чем у реакта (e.g. JSX.InputHTMLAttributes<HTMLInputElement>). Показалось, не очень удобным работать с action и useAction - методами для асинхронных запросов. Один из самых быстрых фреймворков из вообще всех. Документация хорошая. В целом - годно.

3. qwik - т.н. resumable фреймворк. "Resumability is about pausing execution on the server and resuming execution on the client..." Сериализирует слушатели, стейт в хтмл на сервере и передает на клиент. Необходимо перестраивать ментальную модель при создании приложения, так как все обработчики событий лениво подгружаются, после срабатывания события, что может быть проблемой при медленном соединении (нажали на кнопку и ждем пару секунд пока функция скачается и выполнится). Но зато лучший tti по сравнению с другими фреймворками, так как скачивается минимум скриптов. В issue на гитхабе кто-то из контрибьюторов написал, что "The constraint is that the store needs to be serialized when the application is paused and therefore it needs to get a reference to the correct DOM", так что глобальный стейт, по сути, должен храниться в одном из компонентов (я засунул в один из layout`ов) и передаваться через контекст потомкам. Исходя из архитектуры фреймворка логично, но не совсем удобно, если глобальный стейт будет огромным. Придется писать отдельный верхнеуровневый компонент, содержащий всю логику. Мейнтейнер пишет, что "...in Qwik the state must be part of the tree, for technical reason but globals are in general something to avoid even in other templates when doing SSR." Ну еще плюсом zod встроен в routeAction. Документация хорошая. Но инструмент несколько ограничивает из-за своего подхода, не уверен, что погоня за TTI стоит того. Немного странный DX, от того, что нужно оборачивать множество функций в $. В целом норм, но как-то не зашло.

4. svelte - исчезающий фреймворк (или можно даже сказать компилятор, кто-то пишет "...компилятор, который получает ваш код и выдает нативный JavaScript, который напрямую взаимодействует с DOM без необходимости в каком-либо посреднике."). Код исполняется в топологическом порядке, за счет чего обеспечивается реактивность. Если смотреть в плейграунде JS output будет выглядеть как [^1]. Показалось, что пушка. Прям приятно использовать. Изи ту лёрн, очень хорошая документация. Очень быстрый, 5 версия даже быстрее солида. Навскидку из минусов вспоминается только отсутствии типизации при использовании data в шаблоне, так как data лежит в соседнем ts файле и тип не подтягивается, приходится явно кастовать через as (наверняка что-то еще было связанное с асинхронщиной, но уже не вспомню). И немного сбивает с толку их объявление переменных через const в шаблоне и вообще синтаксис шаблона выглядит странно (special tags в документации). Однозначно попробовал бы в продакшене.

5. angular - однозначно самый высокий порог входа из всех. Другая ментальная модель, observables, rxjs, декораторы, инъекции, куча всего из коробки. Чтобы писать, нужно во всем этом разобраться. Удобно создавать компоненты, директивы, сервисы через angular cli. В качестве тест раннера ангуляр использует карму, которую только он, в принципе, и использует. Но уже собираются переходить на web test runner, хотя с 17 версией все еще идет карма. Ну и jasmine в качестве тестового фреймворка (судя по какому-то бенчмарку быстрее jest, но не эмулирует действия с DOM, как jest с помощью jsdom, для этого юзает карму, и открывается браузер из-за этого. вообще не уверен, что быстрее jest из-за этого, на самом деле, но тут хз). Одни и те же вещи можно сделать несколькими способами, что сбивает, нужна экспертиза и best practices, чтобы понять, какой способ лучше. Можно сделать условный рендеринг через ngIf (типа v-if во vue) и через template control flow @if. Реактивность реализовать через observables и сигналы. Написать компоненты standalone или нет и тд. В каждой версии фреймворка добавляют что-то новое и ответы на стековерфлоу по нужному вопросу могут быть по уже не самому лучшему решению к актуальной версии фреймворка (очень сбивало с толку, когда по одному запросу в гугле выдается несколько ответов на stackoverflow и различных статей на сайтах, которую решают одну проблему по-разному, отсутствие экспертизы в angular не позволяет понять, какой способ лучше в данной ситуации на данной версии фреймворка). С 14 версии можно юзать standalone компоненты, чтобы не использовать декоратор NgModule. Я, допустим, писал на 17 версии и вообще не юзал NgModule, но в чуть более старом коде 100% он будет использоваться, т.е. надо будет разобраться еще, как работает NgModule (особо не разбирался, так как смотрел фреймворки в крупную клетку). Много времени потратил, стараясь написать кастомный инпут компонент. Сделал, используя реактовский подход. Потом обнаружил, что для удобной работы с формой компонент инпута должен имплементировать стандартный интерфейс ControlValueAccessor. Для этого необходимо было добавить несколько методов в компонент, дописать пару строк в provider. В общем пришлось написать второй компонент инпута. Создание сторы показалось самым многословным из всех фреймворков (из встроенных решений). Старая версия документации, учитывая большое количество всего во фреймворке, показалась очень сухой и с малым количеством примеров. Имхо, читается прям тяжело. Новая версия лучше, более подробная, но она в бета версии, наполнении меньше, чем в старой версии и точно нашел в ней пару косяков. Туториал неплохой, но очень маленький, хотелось бы побольше разделов по более продвинутым вещам. Также дока не объясняет концепции, лежащие в основе, а было бы очень неплохо, учитывая сложность инструмента. Пожалуй, больше всего времени потратил именно с этим фреймворком. В целом, инструмент мощный, но без разработчика, имеющего опыт с данным фреймворком и код ревью или большой экспертизы, скорее всего, будешь говнокодить. В продакшене бы, скорее, попробовал, но точно не как единственный фронт на проекте.

6. remix - метафреймворк реакта от Кента Доддса и react router team. Продающий лендос - классный. В целом - почти тот же реакт (внезапно). Удобное error boundary. loader и action - функции, выполняющиеся на сервере, можно хранить различные секреты и токены, обращаться к бд. с action формы можно отправлять без js, т.к. код выполняется на сервере. При срабатывании action автоматом следует выполнение loader, т.е. гет запросом подтягиваются актуальные данные после внесения изменений в бд, удобно. useLoaderData в потомках имеет доступ ко всем данным, полученным в родителе через loader (action наверно тоже так работает, не проверял), поэтому переносить компонент надо аккуратно, следя за тем, что не использует useLoaderData родителя. В целом есть люди, которые жалуется на такую неявную связь loader и action и компонента. Дока вроде норм, но там многого и не надо, т.к. основа - реакт. Но туториал жесть - ~ 70 экранов текста, кода и картинок на одной странице. Хоть и есть навигация в сайдбаре, имхо психологически воспринимается тяжеловато, когда видишь такую простыню текста. Толком и сказать больше нечего, чувствуется как небольшая обертка над реактом, умеющая в ssr.

7. next - метафреймворк реакта от vercel. дев сервер запускается заметно дольше, чем на остальных фреймворках, секунд 6-7 на моем компе. В отличие от ремикса может и в ssg. Патчит нативный fetch из web api. Забавно, что документация по use server и use client присутствует в доке некста и отсутствует в доке реакта. эндпоинты можно прописывать для каждого отдельного роута в папке api в функции GET, и потом обращаться к ним типа fetch http://foo.bar/api/baz, интересно. после action запроса, данные сами обновляются после их изменения, если укаазть revalidateTag. то есть не идет последующий гет запрос как в ремиксе. если отправить сразу пачку запросов на изменение какой-либо сущности, то она обновляется jsом, (без гет запроса) через какой-то таймаут после последного запроса (в ремиксе, e.g., если мы отправим пачку (пост, делит и т.д) запросов, то после каждого будет отправляться гет, который будет отменяться после следующего не гет-запроса и потом уже выполнится последний). Некоторые блоки с клиентской логикой придется выносить в отдельные блоки и помечать use client, так как по умолчанию все компоненты - use server, несколько ограничивает. В 13 нексте изменили подход по роутингу и, попутно, фетчингу данных, теперь используя app директорию не нужно юзать getServerSideProps (которая работает только в pages директории). Несколько вариантов роутинга - легче будет запутаться. В целом, кажется, что инструмент мощнее, чем ремикс, но, как и многих, смущает этот use server. Вынуждает либо писать бэк на ноде, что ведет к вендорлоку и не масштабируемо, либо использовать backend for frontend подход (в очень крупную клетку - как reverse proxy) для обращения к сервисам, что ведет к дублированию кода на "бэке фронта" и сервиса. Часть core-team реакта перешли в vercel для работы над некстом. Реакт, по сути, начинает становиться не самостоятельным инструментов, а библиотекой, на чьей основе строят фреймворки более высокого уровня (next, remix, gatsby). В доке прямо советуют брать некст для создания новых проектов. Выглядит занятно, кто-то говорит, что это будущее фронта, интересно, куда эти "юз сервер" могут привести в дальнейшем. 

---

[^1]: приложение 1:

input

```js
<script>
	let age = 0;
	let year = 0
	function asd() {
		const currentAge = new Date().getFullYear()
		age = currentAge - year
	}
</script>
<div>
	 <input bind:value={year} placeholder='type here' />
	<button on:click={asd} >qwe</button>
	<p>{age}</p>
</div>

```

output

```js
import {
    SvelteComponent,
    append,
    attr,
    detach,
    element,
    init,
    insert,
    listen,
    noop,
    run_all,
    safe_not_equal,
    set_data,
    set_input_value,
    space,
    text,
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_fragment(ctx) {
    let div;
    let input;
    let t0;
    let button;
    let t2;
    let p;
    let t3;
    let mounted;
    let dispose;

    return {
        c() {
            div = element("div");
            input = element("input");
            t0 = space();
            button = element("button");
            button.textContent = "qwe";
            t2 = space();
            p = element("p");
            t3 = text(/*age*/ ctx[0]);
            attr(input, "placeholder", "type here");
        },
        m(target, anchor) {
            insert(target, div, anchor);
            append(div, input);
            set_input_value(input, /*year*/ ctx[1]);
            append(div, t0);
            append(div, button);
            append(div, t2);
            append(div, p);
            append(p, t3);

            if (!mounted) {
                dispose = [
                    listen(input, "input", /*input_input_handler*/ ctx[3]),
                    listen(button, "click", /*asd*/ ctx[2]),
                ];

                mounted = true;
            }
        },
        p(ctx, [dirty]) {
            if (dirty & /*year*/ 2 && input.value !== /*year*/ ctx[1]) {
                set_input_value(input, /*year*/ ctx[1]);
            }

            if (dirty & /*age*/ 1) set_data(t3, /*age*/ ctx[0]);
        },
        i: noop,
        o: noop,
        d(detaching) {
            if (detaching) {
                detach(div);
            }

            mounted = false;
            run_all(dispose);
        },
    };
}

function instance($$self, $$props, $$invalidate) {
    let age = 0;
    let year = 0;

    function asd() {
        const currentAge = new Date().getFullYear();
        $$invalidate(0, (age = currentAge - year));
    }

    function input_input_handler() {
        year = this.value;
        $$invalidate(1, year);
    }

    return [age, year, asd, input_input_handler];
}

class App extends SvelteComponent {
    constructor(options) {
        super();
        init(this, options, instance, create_fragment, safe_not_equal, {});
    }
}

export default App;
```
