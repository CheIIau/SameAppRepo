### Summary

> Краткое саммари для будущего меня по использованным фреймворкам. Стоило, конечно, писать по мере разработки, чтобы ничего не забыть, но, к сожалению, писал постфактум, поэтому некоторые моменты, боли, плюсы по части фреймворков уже забылись.

1. lit - очень мало всего из коробки (хотя, вроде, есть достаточно много пакетов на оф странице) низкий уровень абстракции, ощущение, что пишешь на голом js, что одновременно плюс и минус, так как нужно изобретать свои велосипеды на те вещи, что, как правило, идут с фреймворком. Вебкомпоненты - стандарт, который кроме angular больше никто не юзает из фреймворков, хорошая изоляция. Не самое очевидное подключение тейлвинда - для удобства собственная обертка над классом, ну такое себе. От версии к версии фреймворк не сильно меняется, так что документация к первой версии по большей степени актуальна для третьей, вроде даже от Polymer местами подходит. Судя по звездам на гитхабе комьюнити должно быть довольно большое, хотя по факту фреймворк развивается довольно медленно, по сравнению с конкурентами выглядит сырым, хотя, если учитывать тот же полимер, фреймворку больше 7 лет. Css переменные от родителя к ребенку передавать неудобно, нет вычисляемых свойств типа computed (а было бы неплохо), плохенькая документация (по крайней мере, хуже, чем у всех остальных фреймворков). Через их starter-kit создавать проект - боль, через vite - норм. Но, вроде, досточно удобная библиотека для запросов task. В целом, использовать, откровенно, не хочется. На других фрейморках, кажется, продуктивность заметно выше. PS. еще почему-то ts server периодически крашился после установки расширения для вскода для lit.

2. solid - очень близкий api к реакту, так что перекатиться с реакта довольно легко, к тому же есть библиотека, для использования солид-компонентов в реакте, но в этом кроется свое коварство - подходы принципиально разные, необходимо перестроить ментальную модель, и похожий апи немного путает. есть eslint правила для солида с хорошим фиксом (e.g. при попытке деструктуризировать пропсы, скажет, что так потеряется реактивность и сам обернет в splitProps, при попытке присвоить дефолтное значение - обернет в mergeProps. Клёво). Типы ивентов менее удобные чем у реакта (e.g. JSX.InputHTMLAttributes<HTMLInputElement>). Показалось, не очень удобным работать с action и useAction - методами для асинхронных запросов. Один из самых быстрых фреймворков из вообще всех. Документация хорошая. В целом - годно.

3. qwik - т.н. resumable фреймворк. "Resumability is about pausing execution on the server and resuming execution on the client..." Сериализирует слушатели, стейт в хтмл на сервере и передает на клиент. Необходимо перестраивать ментальную модель при создании приложения, так как все обработчики событий лениво подгружаются, после срабатывания события, что может быть проблемой при медленном соединении (нажали на кнопку и ждем пару секунд пока функция скачается и выполнится). Но зато лучший tti по сравнению с другими фреймворками, так как скачивается минимум скриптов. В issue на гитхабе кто-то из контрибьюторов написал, что "The constraint is that the store needs to be serialized when the application is paused and therefore it needs to get a reference to the correct DOM", так что глобальный стейт, по сути, должен храниться в одном из компонентов (я засунул в один из layout`ов) и передаваться через контекст потомкам. Исходя из архитектуры фреймворка логично, но не совсем удобно, если глобальный стейт будет огромным. Придется писать отдельный верхнеуровневый компонент, содержащий всю логику. Мейнтейнер пишет, что "...in Qwik the state must be part of the tree, for technical reason but globals are in general something to avoid even in other templates when doing SSR." Ну еще плюсом zod встроен в routeAction. Документация хорошая. Но инструмент несколько ограничивает из-за своего подхода, не уверен, что погоня за TTI стоит того. В целом норм, но как-то не зашло.

4. svelte - исчезающий фреймворк (или можно даже сказать компилятор, кто-то пишет "...компилятор, который получает ваш код и выдает нативный JavaScript, который напрямую взаимодействует с DOM без необходимости в каком-либо посреднике."). Код исполняется в топологическом порядке, за счет чего обеспечивается реактивность. Если смотреть в плейграунде JS output будет выглядеть как [^1]. Показалось, что пушка. Прям приятно использовать. Изи ту лёрн, очень хорошая документация. Очень быстрый, 5 версия даже быстрее солида. Навскидку из минусов вспоминается только отсутствии типизации при использовании data в шаблоне, так как data лежит в соседнем ts файле и тип не подтягивается, приходится явно кастовать через as (наверняка что-то еще было связанное с асинхронщиной, но уже не вспомню). Однозначно попробовал бы в продакшене.

5. angular - однозначно самый высокий порог входа из всех. Другая ментальная модель, observables, rxjs, декораторы, инъекции, куча всего из коробки. Чтобы писать, нужно во всем этом разобраться. Удобно создавать компоненты, директивы, сервисы через angular cli. В качестве тест раннера ангуляр использует карму, которую только он, в принципе, и использует. Но уже собираются переходить на web test runner, хотя с 17 версией все еще идет карма. Ну и jasmine в качестве тестового фреймворка (судя по какому-то бенчмарку быстрее jest, но не эмулирует действия с DOM,  как jest с помощью jsdom, для этого юзает карму, и открывается браузер из-за этого. вообще не уверен, что быстрее jest из-за этого, на самом деле, но тут хз). Одни и те же вещи можно сделать несколькими способами, что сбивает, нужна экспертиза и best practices, чтобы понять, какой способ лучше. Можно сделать условный рендеринг через ngIf (типа v-if во vue) и через template control flow @if. Реактивность реализовать через observables и сигналы. Написать компоненты standalone или нет и тд.  В каждой версии фреймворка добавляют что-то новое и ответы на стековерфлоу по нужному вопросу могут быть по уже не самому лучшему решению к актуальной версии фреймворка (очень сбивало с толку, когда по одному запросу в гугле выдается несколько ответов на stackoverflow и различных статей на сайтах, которую решают одну проблему по-разному, отсутствие экспертизы в angular не позволяет понять, какой способ лучше в данной ситуации на данной версии фреймворка). С 14 версии можно юзать standalone компоненты, чтобы не использовать декоратор NgModule. Я, допустим, писал на 17 версии и вообще не юзал NgModule, но в чуть более старом коде 100% он будет использоваться, т.е. надо будет разобраться еще, как работает NgModule (особо не разбирался, так как смотрел фреймворки в крупную клетку). Много времени потратил, стараясь написать кастомный инпут компонент. Сделал, используя реактовский подход. Потом обнаружил, что для удобной работы с формой компонент инпута должен имплементировать стандартный интерфейс ControlValueAccessor. Для этого необходимо было добавить несколько методов в компонент, дописать пару строк в provider. В общем пришлось написать второй компонент инпута. Создание сторы показалось самым многословным из всех фреймворков. Старая версия документации, учитывая большое количество всего во фреймворке, показалась очень сухой и с малым количеством примеров. Имхо, читается прям тяжело. Новая версия лучше, более подробная, но она в бета версии, наполнении меньше, чем в старой версии и точно нашел в ней пару косяков. Туториал неплохой, но очень маленький, хотелось бы побольше разделов по более продвинутым вещам. Также дока не объясняет концепции, лежащие в основе, а было бы очень неплохо, учитывая сложность инструмента. Пожалуй, больше всего времени потратил именно с этим фреймворком. В целом, инструмент мощный, но без разработчика, имеющего опыт с данным фреймворком и код ревью или большой экспертизы, скорее всего, будешь говнокодить. В продакшене бы, скорее, попробовал, но точно не как единственный фронт на проекте.

6. remix - TODO
7. next - TODO

---------
[^1]: приложение 1:

input
```js
<script>
	let age = 0;
	let year = 0
	function asd() {
		const currentAge = new Date().getFullYear()
		age = currentAge - year
	}
</script>
<div>
	 <input bind:value={year} placeholder='type here' />
	<button on:click={asd} >qwe</button>
	<p>{age}</p>
</div>

```

output
```js
import {
	SvelteComponent,
	append,
	attr,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	space,
	text
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_fragment(ctx) {
	let div;
	let input;
	let t0;
	let button;
	let t2;
	let p;
	let t3;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			input = element("input");
			t0 = space();
			button = element("button");
			button.textContent = "qwe";
			t2 = space();
			p = element("p");
			t3 = text(/*age*/ ctx[0]);
			attr(input, "placeholder", "type here");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			set_input_value(input, /*year*/ ctx[1]);
			append(div, t0);
			append(div, button);
			append(div, t2);
			append(div, p);
			append(p, t3);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[3]),
					listen(button, "click", /*asd*/ ctx[2])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*year*/ 2 && input.value !== /*year*/ ctx[1]) {
				set_input_value(input, /*year*/ ctx[1]);
			}

			if (dirty & /*age*/ 1) set_data(t3, /*age*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let age = 0;
	let year = 0;

	function asd() {
		const currentAge = new Date().getFullYear();
		$$invalidate(0, age = currentAge - year);
	}

	function input_input_handler() {
		year = this.value;
		$$invalidate(1, year);
	}

	return [age, year, asd, input_input_handler];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;

```