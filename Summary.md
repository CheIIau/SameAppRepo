### Summary

> Краткое саммари для будущего меня по использованным фреймворкам. Стоило, конечно, писать по мере разработки, чтобы ничего не забыть, но, к сожалению, писал постфактум, поэтому некоторые моменты, боли, плюсы по части фреймворков уже забылись.

1. lit - очень мало всего из коробки (хотя, вроде, есть достаточно много пакетов на оф странице) низкий уровень абстракции, ощущение, что пишешь на голом js, что одновременно плюс и минус, так как нужно изобретать свои велосипеды на те вещи, что, как правило, идут с фреймворком (справедливости ради, lit - библиотека). Вебкомпоненты - стандарт, который кроме angular больше никто не юзает из фреймворков, хорошая изоляция. Не самое очевидное подключение тейлвинда - для удобства собственная обертка над классом, ну такое себе. От версии к версии библиотека не сильно меняется, так что документация к первой версии по большей степени актуальна для третьей, вроде даже от Polymer местами подходит. Судя по звездам на гитхабе комьюнити должно быть довольно большое, хотя по факту фреймворк развивается довольно медленно, по сравнению с конкурентами выглядит сырым, хотя, если учитывать тот же полимер, либе больше 7 лет. Css переменные от родителя к ребенку передавать неудобно, нет вычисляемых свойств типа computed (а было бы неплохо), плохая документация (по крайней мере, хуже, чем у всех остальных фреймворков). Одним декоратором задаются как просы компонента, так и внутренее состояние, что дико путает. Т.е. нельзя взглянуть на компонент и понять, что является внутренним состоянием, а что контрактом компонента, так еще получается и весь стейт компонента экспоузится наружу. Непонятно, зачем так сделали. Через их starter-kit создавать проект - боль, через vite - норм. Но, вроде, досточно удобная библиотека для запросов task. В целом, использовать, откровенно, не хочется. На других фреймворках, кажется, продуктивность заметно выше. Но lit и не ставит своей целью быть чем-то вроде реакта или vue и справляется со своей задачей создавать веб-компоненты. Наверно, в сколько угодно серьёзный проект смысла брать нет никакого. Разве что создать пару веб-компонентов и потом использовать где-то еще. Наверно... Но лучше брать stencil. Еслинт правила неплохие, с автофиксом. PS. еще почему-то ts server периодически крашился во время использования расширения для вскода для lit

2. solid - очень близкий api к реакту, так что перекатиться с реакта довольно легко, к тому же есть библиотека, для использования солид-компонентов в реакте, но в этом кроется свое коварство - подходы принципиально разные, необходимо перестроить ментальную модель, и похожий апи немного путает. есть eslint правила для солида с хорошим фиксом (e.g. при попытке деструктуризировать пропсы, скажет, что так потеряется реактивность и сам обернет в splitProps, при попытке присвоить дефолтное значение - обернет в mergeProps. Клёво). Типы ивентов менее удобные чем у реакта (e.g. JSX.InputHTMLAttributes<HTMLInputElement>). Показалось, не очень удобным работать с action и useAction - методами для асинхронных запросов. Один из самых быстрых фреймворков из вообще всех. Документация хорошая. В целом - годно.

3. qwik - т.н. resumable фреймворк. "Resumability is about pausing execution on the server and resuming execution on the client..." Сериализирует слушатели, стейт в хтмл на сервере и передает на клиент. Необходимо перестраивать ментальную модель при создании приложения, так как все обработчики событий лениво подгружаются, после срабатывания события, что может быть проблемой при медленном соединении (нажали на кнопку и ждем пару секунд пока функция скачается и выполнится). Но зато лучший tti по сравнению с другими фреймворками, так как скачивается минимум скриптов. В issue на гитхабе кто-то из контрибьюторов написал, что "The constraint is that the store needs to be serialized when the application is paused and therefore it needs to get a reference to the correct DOM", так что глобальный стейт, по сути, должен храниться в одном из компонентов (я засунул в один из layout`ов) и передаваться через контекст потомкам. Исходя из архитектуры фреймворка логично, но не совсем удобно. Если глобальный стейт будет огромным, придется писать отдельный верхнеуровневый компонент, содержащий всю логику. Мейнтейнер пишет, что "...in Qwik the state must be part of the tree, for technical reason but globals are in general something to avoid even in other templates when doing SSR." Ну еще плюсом zod встроен в routeAction. Документация хорошая. Но инструмент несколько ограничивает из-за своего подхода, не уверен, что погоня за TTI стоит того. Немного странный DX, от того, что нужно оборачивать множество функций в $. В целом норм, но как-то не зашло.

4. svelte - исчезающий фреймворк (или можно даже сказать компилятор, кто-то пишет "...компилятор, который получает ваш код и выдает нативный JavaScript, который напрямую взаимодействует с DOM без необходимости в каком-либо посреднике."). Код исполняется в топологическом порядке, за счет чего обеспечивается реактивность. Если смотреть в плейграунде JS output будет выглядеть как [^1]. Показалось, что пушка. Прям приятно использовать. Изи ту лёрн, очень хорошая документация. Очень быстрый, 5 версия даже быстрее солида. Навскидку из минусов вспоминается только отсутствии типизации при использовании data в шаблоне, так как data лежит в соседнем ts файле и тип не подтягивается, приходится явно указывать (наверняка что-то еще было, связанное с асинхронщиной, но уже не вспомню). И немного сбивает с толку их объявление переменных через const в шаблоне и вообще синтаксис шаблона выглядит странно (special tags в документации). Точно попробовал бы в продакшене.

5. angular - однозначно самый высокий порог входа из всех. Другая ментальная модель, observables, rxjs, декораторы, инъекции, куча всего из коробки. Чтобы писать, нужно во всем этом разобраться. Удобно создавать компоненты, директивы, сервисы через angular cli. В качестве тест раннера ангуляр использует карму, которую только он, в принципе, и использует. Но уже собираются переходить на web test runner, хотя с 17 версией все еще идет карма. Ну и jasmine в качестве тестового фреймворка (судя по какому-то бенчмарку быстрее jest, но не эмулирует действия с DOM, как jest с помощью jsdom, для этого юзает карму, и открывается браузер из-за этого. вообще не уверен, что быстрее jest из-за этого, на самом деле, но тут хз). Одни и те же вещи можно сделать несколькими способами, что сбивает, нужна экспертиза и best practices, чтобы понять, какой способ лучше. Можно сделать условный рендеринг через ngIf (типа v-if во vue) и через template control flow @if. Реактивность реализовать через observables и сигналы. Написать компоненты standalone или нет и тд. В каждой версии фреймворка добавляют что-то новое и ответы на стековерфлоу по нужному вопросу могут быть по уже не самому лучшему решению к актуальной версии фреймворка (очень сбивало с толку, когда по одному запросу в гугле выдается несколько ответов на stackoverflow и различных статей на сайтах, которую решают одну проблему по-разному, отсутствие экспертизы в angular не позволяет понять, какой способ лучше в данной ситуации на данной версии фреймворка). С 14 версии можно юзать standalone компоненты, чтобы не использовать декоратор NgModule. Я, допустим, писал на 17 версии и вообще не юзал NgModule, но в чуть более старом коде 100% он будет использоваться, т.е. надо будет разобраться еще, как работает NgModule (особо не разбирался, так как смотрел фреймворки в крупную клетку). Много времени потратил, стараясь написать кастомный инпут компонент. Сделал, используя реактовский подход. Потом обнаружил, что для удобной работы с формой, компонент инпута должен имплементировать стандартный интерфейс ControlValueAccessor. Для этого необходимо было добавить несколько методов в компонент, дописать пару строк в provider. В общем, пришлось написать второй компонент инпута. Создание сторы показалось самым многословным из всех фреймворков (из встроенных решений). Старая версия документации, учитывая большое количество всего во фреймворке, показалась очень сухой и с малым количеством примеров. Имхо, читается прям тяжело. Новая версия лучше, более подробная, но она в бета версии, наполнение меньше, чем в старой версии и точно нашел в ней пару косяков. Туториал неплохой, но очень маленький, хотелось бы побольше разделов по более продвинутым вещам. Также дока не объясняет концепции, лежащие в основе, а было бы очень неплохо, учитывая сложность инструмента. Пожалуй, больше всего времени потратил именно с этим фреймворком. В целом, инструмент мощный, но без второго разработчика, имеющего опыт с данным фреймворком и код ревью или большой экспертизы, скорее всего, будешь говнокодить. В продакшене бы, скорее, попробовал, но точно не как единственный фронт на проекте.

6. remix - метафреймворк реакта от Кента Доддса и react router team. Продающий лендос - классный. В целом - почти тот же реакт (внезапно). Удобное error boundary. loader и action - функции, выполняющиеся на сервере, можно хранить различные секреты и токены, обращаться к бд (почти как use server функции в нексте). с action формы можно отправлять без js, т.к. код выполняется на сервере. При срабатывании action автоматом следует выполнение loader, т.е. гет запросом подтягиваются актуальные данные после внесения изменений в бд, удобно. useLoaderData в потомках имеет доступ ко всем данным, полученным в родителе через loader (action наверно тоже так работает, не проверял), поэтому переносить компонент надо аккуратно, следя за тем, чтобы он не использовал useLoaderData родителя. В целом есть люди, которые жалуется на такую неявную связь loader и action и компонента. Дока вроде норм, но там многого и не надо, т.к. основа - реакт. Но туториал жесть - ~ 70 экранов текста, кода и картинок на одной странице. Хоть и есть навигация в сайдбаре, имхо психологически воспринимается тяжеловато, когда видишь такую простыню текста. Толком и сказать больше нечего, чувствуется как небольшая обертка над реактом, умеющая в ssr.

7. next - метафреймворк реакта от vercel. Дев сервер запускается заметно дольше, чем на остальных фреймворках, секунд 6-7 на моем компе. В отличие от ремикса может и в ssg. Патчит нативный fetch из web api. Забавно, что документация по use server и use client присутствует в доке некста и отсутствует в доке реакта. Эндпоинты можно прописывать для каждого отдельного роута в папке api в функции GET, и потом обращаться к ним типа fetch http://foo.bar/api/baz, интересно. после action запроса, данные сами обновляются после их изменения, если укаазть revalidateTag. то есть не идет последующий гет запрос как в ремиксе. если отправить сразу пачку запросов на изменение какой-либо сущности, то она обновляется jsом, (без гет запроса) через какой-то таймаут после последного запроса (в ремиксе, e.g., если мы отправим пачку (пост, делит и т.д) запросов, то после каждого будет отправляться гет, который будет отменяться после следующего не гет-запроса и потом уже выполнится последний). Некоторые блоки с клиентской логикой придется выносить в отдельные блоки и помечать use client, так как по умолчанию все компоненты - use server, несколько ограничивает. В 13 нексте изменили подход по роутингу и, попутно, фетчингу данных, теперь используя app директорию не нужно юзать getServerSideProps (которая работает только в pages директории). Несколько вариантов роутинга - легче будет запутаться. В целом, кажется, что инструмент мощнее, чем ремикс, но, как и многих, смущает этот use server. Вынуждает либо писать бэк на ноде, что ведет к вендорлоку и не масштабируемо, либо использовать backend for frontend подход (в очень крупную клетку - как reverse proxy) для обращения к сервисам, что ведет к дублированию кода на "бэке фронта" и сервиса. Часть core-team реакта перешли в vercel для работы над некстом. Реакт, по сути, начинает становиться не самостоятельным инструментов, а библиотекой, на чьей основе строят фреймворки более высокого уровня (next, remix, gatsby). В доке прямо советуют брать некст для создания новых проектов. Выглядит занятно, кто-то говорит, что это будущее фронта, интересно, куда эти "юз сервер" могут привести в дальнейшем.

8. alpine - в доке указано, что фреймворк, но по факту не так. Очень минималистичная библиотека, где есть чуть более дюжины атрибутов и пара тройка свойств. Чисто для добавления логики в html-документ, синтаксис атрибутов наподобие vue, но вместо префикса 'v', тут 'x' (x-model, x-if, x-bind, x-on...). В доке пишут, что "...jQuery for the modern web". Может пригодиться если нужно добавить минимум js на какой-нибудь лендос, добавить чуть логики на статичную страницу (если нужно что-то чуть сложнее, наверно, проще найти готовое решение в виде библиотеки на jquery, благо их полно). Для более сложных приложений определенно не подходит. Для своих нужд инструмент хороший, очень простой, интуитивно понятный (настолько, что можно пробежать глазами доку за 5 минут и уже начать использовать безо всяких проблем). Бизнес-модель, как я понял, у них выстроена на продаже готовых UI компонентов на алпайне за $129 (всякие интеграции с чарт.джс, карусели, аккордеоны и тд). Интересно, много ли людей это покупают, учитывая бесплатные решения на том же jquery. P.S. Страницу с постами даже делать не стал, потому что, по сути, получается просто MPA практически на ванильном js с небольшой библиотекой вдовесок. Тыкать особо нечего.

9. stencil. первое впечатление - роутер не работает, открыто issue на это, страница на гитхабе заброшена почти как 2 года. збс. есть другой старый роутер, но он deprecated, пишут, что работает (сам не проверял). Взял другое решение и еле заставил работать. Ссылки на js модули в хтмл файле должны указывать не на исходный файл, а на уже сбилженный в папке www/build. У них так и подключаются их главные js файлы библиотеки. Почему это нельзя было оставить на rollup непонятно, но жопа дико сгорела, потому что не мог найти причину, почему выдает 404 при подключении js файла. При создании проекта можно выбрать различные стартовые конфигурации, одна из которых работает на старой версии библиотеки. В общем, ощущение, что библиотека и экосистема заброшена, хотя обновления либы постоянно выходят. Да и звезд на гитхабе много. Странно, короче. Подключить тейлвинд можно плагином и если размещать компоненты в шаблоне, то все работает, но при добавлении роутера(видимо, из-за изоляции веб-компонентов или потому что роутер их лениво добавляет), компоненты не видят стили тейлвинда. Пришлось подключать css файл тейлвинда напрямую в каждый компонент в декораторе. Короче, как и в lit, эта изоляция веб-компонентов иногда мешает. В отличие от lit юзает jsx, так что не нужны сторонние плагины для подсветки синтаксиса, автокомплита и тд для вскода, и синтаксис привычнее, чем в лит. HMR еще срабатывает в половине случаев, особенно в вещах связанных со стилями и добавлением роутов. Иногда приходилось даже перезапускать дев-сервер. Удобная стора, можно мутировать, а можно задавать новое состояние через set. Забыл еслинт прикрутить, там у них набор правил есть для либы, но вспомнил про него уже после. Уже лень ставить. Несмотря на все косяки, ощущается привычнее, чем лит, сделал то же приложение раза в 2 быстрее.

---

[^1]: приложение 1:

input

```js
<script>
	let age = 0;
	let year = 0
	function asd() {
		const currentAge = new Date().getFullYear()
		age = currentAge - year
	}
</script>
<div>
	 <input bind:value={year} placeholder='type here' />
	<button on:click={asd} >qwe</button>
	<p>{age}</p>
</div>

```

output

```js
import {
    SvelteComponent,
    append,
    attr,
    detach,
    element,
    init,
    insert,
    listen,
    noop,
    run_all,
    safe_not_equal,
    set_data,
    set_input_value,
    space,
    text,
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_fragment(ctx) {
    let div;
    let input;
    let t0;
    let button;
    let t2;
    let p;
    let t3;
    let mounted;
    let dispose;

    return {
        c() {
            div = element("div");
            input = element("input");
            t0 = space();
            button = element("button");
            button.textContent = "qwe";
            t2 = space();
            p = element("p");
            t3 = text(/*age*/ ctx[0]);
            attr(input, "placeholder", "type here");
        },
        m(target, anchor) {
            insert(target, div, anchor);
            append(div, input);
            set_input_value(input, /*year*/ ctx[1]);
            append(div, t0);
            append(div, button);
            append(div, t2);
            append(div, p);
            append(p, t3);

            if (!mounted) {
                dispose = [
                    listen(input, "input", /*input_input_handler*/ ctx[3]),
                    listen(button, "click", /*asd*/ ctx[2]),
                ];

                mounted = true;
            }
        },
        p(ctx, [dirty]) {
            if (dirty & /*year*/ 2 && input.value !== /*year*/ ctx[1]) {
                set_input_value(input, /*year*/ ctx[1]);
            }

            if (dirty & /*age*/ 1) set_data(t3, /*age*/ ctx[0]);
        },
        i: noop,
        o: noop,
        d(detaching) {
            if (detaching) {
                detach(div);
            }

            mounted = false;
            run_all(dispose);
        },
    };
}

function instance($$self, $$props, $$invalidate) {
    let age = 0;
    let year = 0;

    function asd() {
        const currentAge = new Date().getFullYear();
        $$invalidate(0, (age = currentAge - year));
    }

    function input_input_handler() {
        year = this.value;
        $$invalidate(1, year);
    }

    return [age, year, asd, input_input_handler];
}

class App extends SvelteComponent {
    constructor(options) {
        super();
        init(this, options, instance, create_fragment, safe_not_equal, {});
    }
}

export default App;
```
